package xxsurajbxx.game;import java.awt.Graphics;import java.awt.Graphics2D;import java.awt.image.BufferedImage;import java.io.IOException;import java.io.File;import javax.imageio.ImageIO;import java.lang.Math;public class Entity {    private static Entity earray[];    private static int numofEntities;    private static int maxEntities;    static {        maxEntities = 10;        numofEntities = 0;        earray = new Entity[maxEntities];    }    public static void addEntity(String path, double health, int x, int y, int width, int height, int hbw, int hbh) {        if(numofEntities<maxEntities) {            earray[numofEntities++] = new Entity(path, health, x, y, width, height, hbw, hbh);        }    }    public static void drawEntities(Graphics g) {        for(int i=0; i<numofEntities; i++) {            earray[i].drawEntity(g);        }    }    public static void rotateEntities(int x, int y) {        for(int i=0; i<numofEntities; i++) {            double dist = Math.sqrt(Math.pow(earray[i].x-x, 2)+Math.pow(earray[i].y-y,2));            earray[i].angle = (Math.acos(Math.abs(earray[i].x-x)/dist)+Math.asin(Math.abs(earray[i].y-y)/dist))/2;            if(x==earray[i].x&&y<earray[i].y) {earray[i].angle=0;}            else if(x==earray[i].x&&y>earray[i].y) {earray[i].angle=(2*Math.PI*0.50);}            else if(x>earray[i].x&&y==earray[i].y) {earray[i].angle=(2*Math.PI*0.25);}            else if(x<earray[i].x&&y==earray[i].y) {earray[i].angle=(2*Math.PI*0.75);}            else if(x>earray[i].x&&y<earray[i].y) {earray[i].angle=(2*Math.PI*0.25)-earray[i].angle;}            else if(x>earray[i].x&&y>earray[i].y) {earray[i].angle+=(2*Math.PI*0.25);}            else if(x<earray[i].x&&y>earray[i].y) {earray[i].angle=(2*Math.PI*0.75)-earray[i].angle;}            else if(x<earray[i].x&&y<earray[i].y) {earray[i].angle+=(2*Math.PI*0.75);}        }    }    public static boolean collisionCheck(double x, double y, double dmg) {        for(int i=0; i<numofEntities; i++) {            if(Math.abs(x-earray[i].x)<=earray[i].hitBoxWidth/2&&Math.abs(y-earray[i].y)<=earray[i].hitBoxHeight/2) {                earray[i].health-=dmg;                if(earray[i].health<=0) {removeEntity(i);}                return true;            }        }        return false;    }    private static void removeEntity(int index) {        numofEntities--;        for(int i=index; i<numofEntities; i++) {            earray[i] = earray[i+1];        }        earray[numofEntities+1] = null;    }    private BufferedImage sprite;    public int x, y, dx, dy, width, height, hitBoxWidth, hitBoxHeight, velocityX, velocityY;    public boolean falling, jumping, doubleJumped;    public double angle, health;    public Entity(String path, double health, int x, int y, int width, int height, int hitBoxWidth, int hitBoxHeight) {        try {sprite = ImageIO.read(new File(path));}        catch(IOException e) {e.printStackTrace();}        this.health = health;        this.x = x;        this.y = y;        this.width = width;        this.height = height;        this.dx = x-(width/2);        this.dy = y-(height/2);        this.hitBoxHeight = hitBoxHeight;        this.hitBoxWidth = hitBoxWidth;        falling=false;        jumping=false;        doubleJumped=false;    }    public Entity(double health, int x, int y, int width, int height, int hitBoxWidth, int hitBoxHeight) {        sprite = null;        this.health = health;        this.x = x;        this.y = y;        this.width = width;        this.height = height;        this.dx = x-(width/2);        this.dy = y-(height/2);        this.hitBoxHeight = hitBoxHeight;        this.hitBoxWidth = hitBoxWidth;        falling=false;        jumping=false;        doubleJumped=false;    }    public void drawEntity(Graphics g) {        if(sprite!=null) {            dx = x-(width/2);            dy = y-(height/2);            Graphics2D g2 = (Graphics2D)g;            g2.rotate(angle, x, y);            g2.drawImage(sprite, dx, dy, width, height, null);            g2.rotate(-angle, x, y);        }    }    private int lwr_bnd, mx_spd;    public void jump(int LOWER_BOUND, int MAX_SPEED) {        if(velocityY==0) {            velocityY = -MAX_SPEED;            lwr_bnd = LOWER_BOUND;            mx_spd = MAX_SPEED;            jumping=true;        }        else if(!doubleJumped) {            velocityY = -MAX_SPEED;            lwr_bnd = LOWER_BOUND;            mx_spd = MAX_SPEED;            jumping=true;            falling=false;            doubleJumped=true;        }    }    public void move() {        x+=velocityX;        y+=velocityY;        if(jumping||falling) {            if(velocityY==0) {jumping=false; falling=true;}            if(velocityY<=mx_spd) {velocityY+=5;}            if(y+height>lwr_bnd) {velocityY=0; y=lwr_bnd-height; doubleJumped=false; falling=false;}        }    }}